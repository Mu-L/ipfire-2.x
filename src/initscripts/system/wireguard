#!/bin/sh
###############################################################################
#                                                                             #
# IPFire.org - A linux based firewall                                         #
# Copyright (C) 2024 Michael Tremer <michael.tremer@ipfire.org>               #
#                                                                             #
# This program is free software: you can redistribute it and/or modify        #
# it under the terms of the GNU General Public License as published by        #
# the Free Software Foundation, either version 3 of the License, or           #
# (at your option) any later version.                                         #
#                                                                             #
# This program is distributed in the hope that it will be useful,             #
# but WITHOUT ANY WARRANTY; without even the implied warranty of              #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the               #
# GNU General Public License for more details.                                #
#                                                                             #
# You should have received a copy of the GNU General Public License           #
# along with this program.  If not, see <http://www.gnu.org/licenses/>.       #
#                                                                             #
###############################################################################

. /etc/sysconfig/rc
. ${rc_functions}
. /etc/rc.d/init.d/networking/functions.network

INTF="wg0"

eval $(/usr/local/bin/readhash /var/ipfire/wireguard/settings)

generate_config() {
	echo "[Interface]"
	echo "PrivateKey = ${PRIVATE_KEY}"

	# Optionally set the port
	if [ -n "${PORT}" ]; then
		echo "ListenPort = ${PORT}"
	fi

	local IFS=','

	local id
	local enabled
	local type
	local name
	local pubkey
	local endpoint
	local port
	local remote_subnets
	local remarks
	local local_subnets
	local psk
	local keepalive
	local _rest

	local local_subnet
	local remote_subnet

	# Flush firewall rules
	iptables -F WGBLOCK

	# Flush all previously set routes
	ip route flush dev "${INTF}"

	# Add the client pool
	if [ -n "${CLIENT_POOL}" ]; then
		ip route add "${CLIENT_POOL}" dev "${INTF}"
	fi

	local args
	local src

	while read -r id enabled type name pubkey endpoint port remote_subnets \
			remarks local_subnets psk keepalive _rest; do
		# Skip peers that are not enabled
		[ "${enabled}" = "on" ] || continue

		echo "[Peer]"
		echo "PublicKey = ${pubkey}"

		# Set PSK (if set)
		if [ -n "${psk}" ]; then
			echo "PresharedKey= ${psk}"
		fi

		# Set endpoint
		if [ -n "${endpoint}" ]; then
			echo "Endpoint = ${endpoint}${port:+:}${port}"
		fi

		# Set routes
		if [ -n "${remote_subnets}" ]; then
			echo "AllowedIPs = ${remote_subnets//|/, }"

			# Apply the routes
			if [ "${type}" = "net" ]; then
				local_subnets=( "${local_subnets//|/,}" )

				# Find an IP address of the firewall that is inside the routed subnet
				src="$(ipfire_address_in_networks "${local_subnets[@]}")"

				for remote_subnet in ${remote_subnets//|/,}; do
					args=(
						"${remote_subnet}" "dev" "${INTF}"
					)

					# Add the preferred source if we found one
					if [ -n "${src}" ]; then
						args+=( "src" "${src}" )
					fi

					ip route add "${args[@]}"
				done
			fi
		fi

		# Set keepalive
		if [ -n "${keepalive}" ]; then
			echo "PersistentKeepalive = ${keepalive}"
		fi

		# Set blocking rules
		for local_subnet in ${local_subnets//|/ }; do
			for remote_subnet in ${remote_subnets//|/ }; do
				iptables -A WGBLOCK \
					-s "${remote_subnet}" -d "${local_subnet}" -j RETURN
			done
		done
	done < /var/ipfire/wireguard/peers

	# Block all other traffic
	iptables -A WGBLOCK -j REJECT --reject-with icmp-admin-prohibited
}

reload_firewall() {
	# Flush all previous rules
	iptables -F WGINPUT

	if [ "${ENABLED}" = "on" ]; then
		iptables -A WGINPUT -p udp --dport "${PORT}" -j ACCEPT
	fi
}

wg_start() {
	# Reload the firewall
	reload_firewall

	# Create the interface if it does not exist
	if [ ! -d "/sys/class/net/${INTF}" ]; then
		ip link add "${INTF}" type wireguard || return $?
	fi

	# Set up the interface
	ip link set "${INTF}" up

	# Set the MTU
	if [ -n "${MTU}" ]; then
		ip link set "${INTF}" mtu "${MTU}" || return $?
	fi

	# Load the configuration into the kernel
	wg syncconf "${INTF}" <(generate_config) || return $?

	return 0
}

wg_stop() {
	# Reload the firewall
	ENABLED=off reload_firewall

	if [ -d "/sys/class/net/${INTF}" ]; then
		ip link del "${INTF}" || return $?
	fi
}

case "${1}" in
	start)
		if [ "${ENABLED}" != "on" ]; then
			exit 0
		fi

		boot_mesg "Starting WireGuard VPN..."
		wg_start; evaluate_retval
		;;

	stop)
		boot_mesg "Stopping WireGuard VPN..."
		wg_stop; evaluate_retval
		;;

	reload)
		boot_mesg "Reloading WireGuard VPN..."
		wg_start; evaluate_retval
		;;

	restart)
		${0} stop
		sleep 1
		${0} start
		;;

	*)
		echo "Usage: ${0} {start|stop|reload|restart}"
		exit 1
		;;
esac
