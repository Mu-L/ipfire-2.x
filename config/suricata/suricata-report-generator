#!/usr/bin/python3
###############################################################################
#                                                                             #
# IPFire.org - A linux based firewall                                         #
# Copyright (C) 2025  Michael Tremer                                          #
#                                                                             #
# This program is free software: you can redistribute it and/or modify        #
# it under the terms of the GNU General Public License as published by        #
# the Free Software Foundation, either version 3 of the License, or           #
# (at your option) any later version.                                         #
#                                                                             #
# This program is distributed in the hope that it will be useful,             #
# but WITHOUT ANY WARRANTY; without even the implied warranty of              #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the               #
# GNU General Public License for more details.                                #
#                                                                             #
# You should have received a copy of the GNU General Public License           #
# along with this program.  If not, see <http://www.gnu.org/licenses/>.       #
#                                                                             #
###############################################################################

import argparse
import calendar
import collections
import datetime
import email.message
import email.utils
import logging
import reportlab
import reportlab.lib.styles
import reportlab.platypus
import socket
import sqlite3
import subprocess
import tempfile

from reportlab.lib.units import cm, mm

log = logging.getLogger("suricata-report-generator")
log.setLevel(logging.DEBUG)

# i18n
_ = lambda x: x

def row_factory(cursor, row):
	"""
		This is a custom row factory that makes all fields accessible as attributes.
	"""
	# Create a new class with all fields
	cls = collections.namedtuple("Row", [column for column, *args in cursor.description])

	# Parse the row data
	return cls._make(row)

class ReportGenerator(object):
	"""
		This is the main class that handles all the things...
	"""
	def __init__(self, path):
		self.path = path

		# Open the database
		self.db = sqlite3.connect(path)
		self.db.row_factory = row_factory

		# Load a default stylesheet for our document
		self.styles = reportlab.lib.styles.getSampleStyleSheet()

		# Allow to center content
		centered = reportlab.lib.styles.ParagraphStyle(
			name      = "Centered",
			parent    = self.styles["Normal"],
			alignment = reportlab.lib.enums.TA_CENTER,
		)
		self.styles.add(centered)

	def generate(self, output, year, month, week, day):
		"""
			Generates a PDF report.
		"""
		log.debug("Generating report %s..." % output)

		today = datetime.date.today()

		# Daily reports
		if year and month and day:
			try:
				date = datetime.date(year, month, day)
			except ValueError as e:
				log.error("Invalid date: %s-%s-%s" % (year, month, day))
				raise SystemExit(2)

			# Start and end date are the same day
			date_start = date_end = date

		# Monthly reports
		elif year and month:
			date_start = datetime.date(year, month, 1)

			# Determine the last day
			first_weekday, last_day = calendar.monthrange(year, month)
			date_end = datetime.date(year, month, last_day)

			# Cap to today
			date_end = min(date_end, today)

		# Weekly reports
		elif year and week:
			date_start = datetime.date.fromisocalendar(year, week, 1)
			date_end   = datetime.date.fromisocalendar(year, week, 7)

			# Cap to today
			date_end = min(date_end, today)

		# Yearly reports
		elif year:
			date_start = datetime.date(year, 1, 1)
			date_end   = datetime.date(year, 12, 31)

			# Cap to today
			date_end = min(date_end, today)

		# Log the dates
		log.debug("  Dates: %s - %s" % (date_start, date_end))

		# Create a new PDF document
		doc = reportlab.platypus.SimpleDocTemplate(
			output, pagesize=reportlab.lib.pagesizes.A4,

			# Decrease the margins
			leftMargin=5 * mm, rightMargin=5 * mm, topMargin=10 * mm, bottomMargin=15 * mm,
		)

		# Collect everything that should go on the document
		elements = []

		# Create the title page
		self._make_titlepage(elements, date_start, date_end)

		# Add detailed alerts
		self._make_alerts(elements, date_start, date_end, width=doc.width)

		# Render the document
		doc.build(elements, onLaterPages=self._make_page_number)

	def _make_page_number(self, canvas, doc):
		# Fetch the current page number
		number = canvas.getPageNumber()

		# Set the font
		canvas.setFont(self.styles["Normal"].fontName, 9)

		# Write the page number to the right hand bottom
		canvas.drawRightString(200 * mm, 10 * mm, _("Page %s") % number)

	def _make_titlepage(self, elements, date_start, date_end):
		"""
			Generates the title page of the report
		"""
		date_format = "%d %B %Y"

		# What time is it right now?
		now = datetime.datetime.now()

		# Leave some space at the top
		elements.append(reportlab.platypus.Spacer(1, 6 * cm))

		# Show the title
		elements.append(reportlab.platypus.Paragraph(
			_("IPFire Intrusion Prevention Alert Report"), self.styles["Title"],
		))

		# Only show one date if this is a daily report
		if date_start == date_end:
			elements.append(
				reportlab.platypus.Paragraph(
					date_start.strftime(date_format),
					self.styles["Centered"],
				),
			)

		# Otherwise show the date range
		else:
			elements.append(
				reportlab.platypus.Paragraph(
					"%s - %s" % (
						date_start.strftime(date_format),
						date_end.strftime(date_format)
					),
					self.styles["Centered"],
				),
			)

		# Leave some extra space
		elements.append(reportlab.platypus.Spacer(1, 1 * cm))

		# Show when this report was generated and on which host
		elements.append(
			reportlab.platypus.Paragraph(
				_("Generated on %(hostname)s on %(when)s.") % {
					"hostname" : socket.gethostname(),
					"when"     : now.strftime("%d %B %Y %H:%M"),
				},
				self.styles["Centered"],
			),
		)

		# End the page
		elements.append(
			reportlab.platypus.PageBreak(),
		)

	def _make_alerts(self, elements, date_start, date_end, **kwargs):
		"""
			Called to add all alerts in the date range with all their detail.
		"""
		date = date_start

		while date <= date_end:
			self._make_alerts_by_date(elements, date, **kwargs)

			# Move on to the next day
			date += datetime.timedelta(days=1)

	def _make_alerts_by_date(self, elements, date, *, width):
		log.debug("Rendering alerts for %s..." % date)

		# Fetch the alerts
		c = self.db.execute("""
			SELECT
				id,
				datetime(timestamp, 'unixepoch', 'localtime') AS timestamp,

				-- Basic Stuff
				(event ->> '$.src_ip') AS source_address,
				(event ->> '$.src_port') AS source_port,
				(event ->> '$.dest_ip') AS destination_address,
				(event ->> '$.dest_port') AS destination_port,
				(event ->> '$.proto') AS protocol,
				(event ->> '$.icmp_code') AS icmp_code,
				(event ->> '$.icmp_type') AS icmp_type,

				-- Alert Stuff
				(event ->> '$.alert.category') AS alert_category,
				(event ->> '$.alert.signature') AS alert_signature,
				(event ->> '$.alert.signature_id') AS alert_signature_id,
				(event ->> '$.alert.severity') AS alert_severity,
				(event ->> '$.alert.action') AS alert_action,
				(event ->> '$.alert.gid') AS alert_gid,
				(event ->> '$.alert.rev') AS alert_rev
			FROM
				alerts
			WHERE
				date(timestamp, 'unixepoch', 'localtime') = ?
			ORDER BY
				timestamp ASC,
				id ASC
		""", (date.isoformat(),))

		# Start the table with the header
		rows = [
			(_("Time"), _("Signature"), _("Protocol"), _("Source / Destination"))
		]

		while True:
			row = c.fetchone()
			if row is None:
				break

			# Parse the timestamp
			t = datetime.datetime.strptime(row.timestamp, "%Y-%m-%d %H:%M:%S")

			# Append the row
			rows.append((
				t.strftime("%H:%M:%S"),
				"%s %s\n[%s:%s:%s] - %s" % (
					"*" * row.alert_severity,
					row.alert_signature,
					row.alert_gid,
					row.alert_signature_id,
					row.alert_rev,
					row.alert_category,
				),
				row.protocol,
				"%s:%s\n%s:%s" % (
					row.source_address, (row.source_port or row.icmp_code),
					row.destination_address, (row.destination_port or row.icmp_type),
				),
			))

		# Skip if we have found no data
		if len(rows) == 1:
			log.debug("Skipping %s, because we don't have any data" % date)
			return

		# Add a headline
		elements.append(
			reportlab.platypus.Paragraph(
				_("Alerts from %s") % date.strftime("%A, %d %B %Y"),
				self.styles["Heading2"],
			)
		)

		# Create the table
		table = reportlab.platypus.Table(rows,
			# Set the widths of the rows
			colWidths=(
				width * 0.1, width * 0.6, width * 0.1, width * 0.2,
			),

			# Repeat the header after a page break
			repeatRows=1,
		)

		# Style the table
		table.setStyle(
			reportlab.platypus.TableStyle((
				# Make the grid slightly grey
				("GRID", (0, 0), (-1, -1), 0.25, reportlab.lib.colors.grey),

				# Align all content to the top left corners of the cells
				("ALIGN", (0, 0), (-1, -1), "LEFT"),
				("ALIGN", (0, 0), (0, -1), "CENTER"),
				("ALIGN", (2, 0), (2, -1), "CENTER"),
				("VALIGN", (0, 0), (-1, -1), "TOP"),

				# Chose a much smaller font size
				("FONTSIZE", (0, 0), (-1, -1), 8),

				# Alternate the background colours of the rows
				("ROWBACKGROUNDS", (0, 1), (-1, -1), [
					reportlab.lib.colors.white,
					reportlab.lib.colors.lightgrey,
				]),
			)),
		)

		# Append the table to the output
		elements.append(table)

		# End the page
		elements.append(
			reportlab.platypus.PageBreak(),
		)

	def email(self, recipients, sender, **kwargs):
		"""
			Generates an email with the report
		"""
		log.debug("Sending an email from %s to %s" % (sender, recipients))

		# Fetch the hostname
		hostname = socket.gethostname()

		# Create a new message
		msg = email.message.EmailMessage()

		# Set the sender
		msg.add_header("From", sender)

		# Add them to the email
		msg.add_header("To", ", ".join(recipients))

		# Set the Subject
		msg.add_header(
			"Subject", "[REPORT] Intrusion Prevention System Alerts from %s" % hostname,
		),

		# Compose the content
		content = [
			_("To whom it may concern,"),
			"",
			_("The IPFire Intrusion Preventsion System is sending you the attached report."),
		]

		# Add the content to the email
		msg.set_content("\n".join(content))

		# Generate the report & attach it to the email
		with tempfile.NamedTemporaryFile() as f:
			# Generate
			self.generate(output=f.name, **kwargs)

			# Attach
			msg.add_attachment(
				f.read(), maintype="application", subtype="pdf", filename="report.pdf",
			)

		# Show the email
		log.debug(msg.as_string())

		# Send the email
		p = subprocess.Popen(
			["/usr/sbin/sendmail", "-t", "-oi", "-f", sender],
			text=True,
			stdin=subprocess.PIPE,
			stdout=subprocess.PIPE,
			stderr=subprocess.STDOUT,
		)

		# Pipe the email into sendmail
		stdout, stderr = p.communicate(msg.as_string())

		if not p.returncode == 0:
			log.error("Failed to send email. sendmail returned %s:" % p.returncode)
			if stdout:
				log.error(stdout)

		log.debug("Successfully send email to %s" % ", ".join(recipients))


def setup_logging(loglevel=logging.INFO):
	log.setLevel(loglevel)

	# Write everything to the console
	handler = logging.StreamHandler()
	log.addHandler(handler)

	handler.setLevel(loglevel)

	return log

def main():
	parser = argparse.ArgumentParser(description="Reporter Generator for Suricata")

	# Command Line Arguments
	parser.add_argument("--verbose", "-v", action="count", help="Be more verbose")
	parser.add_argument("--database", help="Database",
		default="/var/log/suricata/reporter.db")

	# Require some output parameters
	group = parser.add_mutually_exclusive_group(required=True)
	group.add_argument("--output", "-o", help=_("Output Path"))
	group.add_argument("--email-recipient", nargs="*", dest="recipients",
		help=_("Send the report to these recipients (multiple possible)")
	)

	parser.add_argument("--email-sender", dest="sender", help=_("Email Sender"))

	# Select the time
	parser.add_argument("--year", type=int, required=True,
		help=_("Year of the report (e.g. 2025)"))
	parser.add_argument("--month", type=int, choices=range(1, 13),
		help=_("Month of the report (1-12)"))

	# We can only use --week or --day, but never both
	group = parser.add_mutually_exclusive_group()
	group.add_argument("--day", type=int, choices=range(1, 32),
		help=_("Day of the month (1-31)"))
	group.add_argument("--week", type=int, choices=range(1, 54),
		help=_("ISO calendar week number (1-53)"))

	# Parse command line arguments
	args = parser.parse_args()

	# Check if we have an email sender
	if args.recipients and not args.sender:
		parser.error("--email-sender= is required if recipients have been passed")

	# Setup logging
	loglevel = logging.WARN

	if args.verbose:
		if args.verbose == 1:
			loglevel = logging.INFO
		elif args.verbose >= 2:
			loglevel = logging.DEBUG

	setup_logging(loglevel=loglevel)

	# Create the report
	generator = ReportGenerator(args.database)

	# Generate!
	if args.output:
		generator.generate(
			output = args.output,
			year   = args.year,
			month  = args.month,
			week   = args.week,
			day    = args.day,
		)

	# Email!
	elif args.recipients:
		generator.email(
			recipients = args.recipients,
			sender     = args.sender,
			year       = args.year,
			month      = args.month,
			week       = args.week,
			day        = args.day,
		)

if __name__ == "__main__":
	main()
