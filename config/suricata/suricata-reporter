#!/usr/bin/python3
###############################################################################
#                                                                             #
# IPFire.org - A linux based firewall                                         #
# Copyright (C) 2025  Michael Tremer                                          #
#                                                                             #
# This program is free software: you can redistribute it and/or modify        #
# it under the terms of the GNU General Public License as published by        #
# the Free Software Foundation, either version 3 of the License, or           #
# (at your option) any later version.                                         #
#                                                                             #
# This program is distributed in the hope that it will be useful,             #
# but WITHOUT ANY WARRANTY; without even the implied warranty of              #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the               #
# GNU General Public License for more details.                                #
#                                                                             #
# You should have received a copy of the GNU General Public License           #
# along with this program.  If not, see <http://www.gnu.org/licenses/>.       #
#                                                                             #
###############################################################################

import argparse
import asyncio
import configparser
import datetime
import email.message
import email.utils
import json
import logging
import logging.handlers
import multiprocessing
import os
import queue
import signal
import socket
import subprocess
import sys

# Fetch the hostname
HOSTNAME = socket.gethostname()

# Email Settings
EMAIL_FROM = "IPFire Intrusion Prevention System <%s>"

log = logging.getLogger("suricata-reporter")
log.setLevel(logging.DEBUG)

# i18n
_ = lambda x: x

class Reporter(object):
	"""
		This is the main class that handles all the things...
	"""
	def __init__(self, config):
		# Parse the configuration file
		self.config = configparser.ConfigParser()
		self.config.read(config)

		# Fetch CPU count
		workers = self.config.getint("DEFAULT", "workers",
			fallback=multiprocessing.cpu_count())

		# Check if workers are a positive number
		if workers < 1:
			log.error("Invalid number of workers: %s" % workers)
			raise SystemExit(1)

		# Fetch the current event loop
		self.loop = asyncio.get_running_loop()

		# Have we terminated?
		self.is_terminated = asyncio.Event()

		# Create an events queue
		self.queue = multiprocessing.Queue(1024)

		# Create as many workers as we have processors
		self.workers = [
			Worker(reporter=self) for _ in range(workers)
		]

		# Register any signals
		for signo in (signal.SIGINT, signal.SIGTERM):
			self.loop.add_signal_handler(signo, self.terminate)

		# Create the socket
		self.sock = self._create_socket()

	@property
	def socket_path(self):
		return self.config.get("DEFAULT", "socket",
			fallback="/var/run/suricata/reporter.socket")

	def _create_socket(self):
		"""
			Creates a new socket to receive messages on
		"""
		# Create a new, non-blocking UNIX datagram socket
		sock = socket.socket(socket.AF_UNIX, socket.SOCK_DGRAM|socket.SOCK_NONBLOCK)

		# Bind to the some path
		try:
			sock.bind(self.socket_path)
		except OSError as e:
			log.error("Failed to bind to socket: %s" % e)

			# Terminate immediately
			raise SystemExit(1)

		# Call something whenever we receive data on the socket
		self.loop.add_reader(sock.fileno(), self._receive_message, sock)

		# Return the socket
		return sock

	async def run(self):
		"""
			The main loop of the application.
		"""
		log.debug("Starting reporter...")

		# Start all workers
		for worker in self.workers:
			worker.start()

		# Wait until we have terminated
		await self.is_terminated.wait()

		log.debug("Reporter has exited")

	def terminate(self):
		"""
			Called when the reporter is supposed to terminate.
		"""
		log.debug("Terminating...")

		# We are no longer running
		self.is_terminated.set()

		# Remove the socket so we won't receive any more data
		try:
			os.unlink(self.socket_path)
		except OSError as e:
			log.error("Failed to remove %s: %s" % (self.socket_path, e))

		# Close the queue
		self.queue.close()

		# Terminate all workers
		for worker in self.workers:
			worker.terminate()

		# Wait until all workers have terminated
		for worker in self.workers:
			worker.join()

	def _receive_message(self, sock):
		"""
			Called when there is some socket activity.

			It will read the entire datagram and push it into the queue.
		"""
		# Read the data from the socket
		data, _ = sock.recvfrom(65535)

		# Push the data straight into the queue
		try:
			self.queue.put(data, block=False)

		# Log a message if the queue is full
		except queue.Full as e:
			log.warning("Failed to push event into the queue. The queue seems to be full.")

		# Ignore if the queue has been closed
		except ValueError:
			pass


class Worker(multiprocessing.Process):
	def __init__(self, reporter):
		super().__init__()

		# Store the reporter
		self.reporter = reporter

	@property
	def config(self):
		"""
			Proxy to access the configuration file
		"""
		return self.reporter.config

	def run(self):
		"""
			This is the main entry point for workers...
		"""
		log.debug("Worker %s launched" % self.pid)

		# Reset signal handlers
		for signo in (signal.SIGINT, signal.SIGTERM):
			signal.signal(signo, signal.SIG_DFL)

		# Loop for forever
		while True:
			try:
				event = self.reporter.queue.get(block=True)

			# If the queue has been closed, we immediately exit
			except ValueError:
				break

			# Parse the event
			try:
				event = Event(event)

			# Skip any events we could not decode
			except ValueError as e:
				log.warning("Failed to decode event: %s" % e)
				continue

			# Log the event
			#log.debug("Received event in worker %s: %s" % (self.pid, event))

			# Process the event
			self.process(event)

		log.debug("Worker %s terminated" % self.pid)

	def process(self, event):
		"""
			Called whenever we have received an event
		"""
		# Process by type
		if event.type == "alert":
			return self.process_alert(event)

		# We don't care about anything else for now
		return

	def process_alert(self, event):
		"""
			Called to process alerts
		"""
		# Log the event
		log.debug("Received alert: %s" % event)

		# Send to syslog
		if self.config.getboolean("syslog", "enabled", fallback=False):
			self.send_to_syslog(event)

		# Send an email
		if self.config.getboolean("email", "enabled", fallback=False):
			self.send_alert_email(event)

	def send_to_syslog(self, event):
		"""
			Sends the event to the local syslog server in fast.log format
		"""
		log.warning(event.fast_log)

	def send_alert_email(self, event):
		"""
			Generates a new email with the alert
		"""
		# Create a new message
		msg = email.message.EmailMessage()

		# Fetch the sender
		email_from = self.config.get("email", "sender", fallback=None)
		if email_from is None:
			email_from = "no-reply@%s" % HOSTNAME

		# Set the sender
		msg.add_header("From", EMAIL_FROM % email_from)

		# Fetch the recipients
		email_recipients = self.config.get("email", "recipients", fallback=None)
		if email_recipients is None:
			log.error("Cannot send alert emails because no recipients have been configured.")
			return

		# Split the recipients
		email_recipients = email.utils.getaddresses([email_recipients])

		# Add them to the email
		msg.add_header("To", ", ".join(
			email.utils.formataddr(recipient) for recipient in email_recipients)
		)

		# Set the Subject
		msg.add_header("Subject", "[ALERT][%s] %s %s - %s" % (HOSTNAME,
			"*" * event.alert_severity, event.alert_signature, event.alert_category))

		# Add the timestamp as Date: header
		msg.add_header("Date", email.utils.format_datetime(event.timestamp))

		# Generate a Message ID
		msg.add_header("Message-ID", email.utils.make_msgid())

		# Compose the content
		content = [
			_("To whom it may concern,"),
			"",
			_("The IPFire Intrusion Preventsion System has raised the following alert:"),
			"",
			"	%-20s : %s" % (_("Signature"), event.alert_signature),
			"	%-20s : %s" % (_("Category"), event.alert_category),
			"	%-20s : %s" % (_("Severity"), event.alert_severity),
			"	%-20s : %s" % (_("Timestamp"), event.timestamp.strftime("%A, %d %B %Y at %H:%M:%S %Z")),
			"	%-20s : %s" % (_("Source"), event.source_address),
			"	%-20s : %s" % (_("Destination"), event.destination_address),
			"	%-20s : %s" % (_("Protocol"), event.protocol),
			"",
		]

		# Show if something was blocked
		if event.alert_action == "blocked":
			content += (
				_("The threat was blocked."), "",
			)

		# Add the content to the email
		msg.set_content("\n".join(content))

		# Log the generated email
		log.debug(msg.as_string())

		# Send the email
		p = subprocess.Popen(
			["/usr/sbin/sendmail", "-t", "-oi", "-f", email_from],
			text=True,
			stdin=subprocess.PIPE,
			stdout=subprocess.PIPE,
			stderr=subprocess.STDOUT,
		)

		# Pipe the email into sendmail
		stdout, stderr = p.communicate(msg.as_string())

		if not p.returncode == 0:
			log.error("Failed to send email. sendmail returned %s:" % p.returncode)
			if stdout:
				log.error(stdout)

		log.debug("Successfully send email to %s" % \
			", ".join(address for name, address in email_recipients))


class Event(object):
	def __init__(self, event):
		# Parse the event
		try:
			self.data = json.loads(event)

		# Raise some ValueError if we could not decode the input
		except json.JSONDecodeError as e:
			raise ValueError("%s" % e) from e

	def __str__(self):
		return "%s" % self.data

	@property
	def type(self):
		return self.data.get("event_type")

	@property
	def timestamp(self):
		t = self.data.get("timestamp")

		# Parse the timestamp
		return datetime.datetime.strptime(t, "%Y-%m-%dT%H:%M:%S.%f%z")

	@property
	def source_address(self):
		return self.data.get("src_ip")

	@property
	def source_port(self):
		return self.data.get("src_port", None)

	@property
	def destination_address(self):
		return self.data.get("dest_ip")

	@property
	def destination_port(self):
		return self.data.get("dest_port", None)

	@property
	def protocol(self):
		return self.data.get("proto")

	@property
	def icmp_code(self):
		return self.data.get("icmp_code", None)

	@property
	def icmp_type(self):
		return self.data.get("icmp_type", None)

	# Alert Stuff

	@property
	def alert(self):
		return self.data.get("alert")

	@property
	def alert_category(self):
		return self.alert.get("category")

	@property
	def alert_signature(self):
		return self.alert.get("signature")

	@property
	def alert_signature_id(self):
		return self.alert.get("signature_id")

	@property
	def alert_severity(self):
		return self.alert.get("severity", 0)

	@property
	def alert_action(self):
		return self.alert.get("action")

	@property
	def alert_gid(self):
		return self.alert.get("gid")

	@property
	def alert_rev(self):
		return self.alert.get("rev")

	@property
	def fast_log(self):
		"""
			Returns the event in a human-readable way (like fast.log)
		"""
		s = []

		# Show if we dropped the packet
		if self.alert_action == "blocked":
			s.append("[Drop]")

		# Add some stars to make it pretty
		s.append("[**]")

		# Show which signature created the alert
		s.append("%s:%s:%s" % (self.alert_gid, self.alert_signature_id, self.alert_rev))

		# Show the signature
		s.append("%s" % self.alert_signature)

		# More stars
		s.append("[**]")

		# Classification
		s.append("[Classification: %s]" % self.alert_category)

		# Priority
		s.append("[Priority: %s]" % self.alert_severity)

		# Protocol
		s.append("{%s}" % self.protocol)

		# Source and Destination Addresses
		s.append("%s:%s -> %s:%s" % (
			self.source_address,
			self.source_port or self.icmp_code,
			self.destination_address,
			self.destination_port or self.icmp_type,
		))

		return " ".join(s)

def setup_logging(loglevel=logging.INFO):
	log.setLevel(loglevel)

	# Log to syslog by default
	handler = logging.handlers.SysLogHandler(address="/dev/log", facility="local5")
	log.addHandler(handler)

	# Format everything
	formatter = logging.Formatter("%(name)s[%(process)d]: %(message)s")
	handler.setFormatter(formatter)

	handler.setLevel(loglevel)

	# Write everything to the console, too
	handler = logging.StreamHandler()
	log.addHandler(handler)

	handler.setLevel(loglevel)

	return log

async def main():
	parser = argparse.ArgumentParser(description="Reporter Service for Suricata")

	# Command Line Arguments
	parser.add_argument("--verbose", "-v", action="count", help="Be more verbose")
	parser.add_argument("--config", "-c",
		help="Configuration File", default="/etc/suricata/reporter.conf")

	# Parse command line arguments
	args = parser.parse_args()

	# Setup logging
	loglevel = logging.WARN

	if args.verbose:
		if args.verbose == 1:
			loglevel = logging.INFO
		elif args.verbose >= 2:
			loglevel = logging.DEBUG

	setup_logging(loglevel=loglevel)

	# Create the repoert
	reporter = Reporter(args.config)

	# Run!
	await reporter.run()

if __name__ == "__main__":
	asyncio.run(main())
