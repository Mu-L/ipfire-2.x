#!/usr/bin/python3
###############################################################################
#                                                                             #
# IPFire.org - A linux based firewall                                         #
# Copyright (C) 2025  Michael Tremer                                          #
#                                                                             #
# This program is free software: you can redistribute it and/or modify        #
# it under the terms of the GNU General Public License as published by        #
# the Free Software Foundation, either version 3 of the License, or           #
# (at your option) any later version.                                         #
#                                                                             #
# This program is distributed in the hope that it will be useful,             #
# but WITHOUT ANY WARRANTY; without even the implied warranty of              #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the               #
# GNU General Public License for more details.                                #
#                                                                             #
# You should have received a copy of the GNU General Public License           #
# along with this program.  If not, see <http://www.gnu.org/licenses/>.       #
#                                                                             #
###############################################################################

import argparse
import asyncio
import datetime
import email.message
import email.utils
import json
import logging
import logging.handlers
import multiprocessing
import os
import queue
import signal
import socket
import subprocess
import sys

# Fetch the hostname
HOSTNAME = socket.gethostname()

# Email Settings
EMAIL_FROM = "michael.tremer@ipfire.org"
EMAIL_TO = "ms@ipfire.org"

SOCKET_PATH = "/var/run/suricata/reporter.socket"

log = logging.getLogger("suricata-reporter")
log.setLevel(logging.DEBUG)

# i18n
_ = lambda x: x

class Reporter(object):
	"""
		This is the main class that handles all the things...
	"""
	def __init__(self):
		# Fetch CPU count
		cpu_count = multiprocessing.cpu_count()

		# Fetch the current event loop
		self.loop = asyncio.get_running_loop()

		# Have we terminated?
		self.is_terminated = asyncio.Event()

		# Create an events queue
		self.queue = multiprocessing.Queue(1024)

		# Create as many workers as we have processors
		self.workers = [
			Worker(reporter=self) for _ in range(cpu_count)
		]

		# Register any signals
		for signo in (signal.SIGINT, signal.SIGTERM):
			self.loop.add_signal_handler(signo, self.terminate)

		# Create the socket
		self.sock = self._create_socket()

	def _create_socket(self):
		"""
			Creates a new socket to receive messages on
		"""
		# Create a new, non-blocking UNIX datagram socket
		sock = socket.socket(socket.AF_UNIX, socket.SOCK_DGRAM|socket.SOCK_NONBLOCK)

		# Bind to the some path
		try:
			sock.bind(SOCKET_PATH)
		except OSError as e:
			log.error("Failed to bind to socket: %s" % e)

			# Terminate immediately
			raise SystemExit(1)

		# Call something whenever we receive data on the socket
		self.loop.add_reader(sock.fileno(), self._receive_message, sock)

		# Return the socket
		return sock

	async def run(self):
		"""
			The main loop of the application.
		"""
		log.debug("Starting reporter...")

		# Start all workers
		for worker in self.workers:
			worker.start()

		# Wait until we have terminated
		await self.is_terminated.wait()

		log.debug("Reporter has exited")

	def terminate(self):
		"""
			Called when the reporter is supposed to terminate.
		"""
		log.debug("Terminating...")

		# We are no longer running
		self.is_terminated.set()

		# Remove the socket so we won't receive any more data
		try:
			os.unlink(SOCKET_PATH)
		except OSError as e:
			log.error("Failed to remove %s: %s" % (SOCKET_PATH, e))

		# Close the queue
		self.queue.close()

		# Terminate all workers
		for worker in self.workers:
			worker.terminate()

		# Wait until all workers have terminated
		for worker in self.workers:
			worker.join()

	def _receive_message(self, sock):
		"""
			Called when there is some socket activity.

			It will read the entire datagram and push it into the queue.
		"""
		# Read the data from the socket
		data, _ = sock.recvfrom(65535)

		# Push the data straight into the queue
		try:
			self.queue.put(data, block=False)

		# Log a message if the queue is full
		except queue.Full as e:
			log.warning("Failed to push event into the queue. The queue seems to be full.")


class Worker(multiprocessing.Process):
	def __init__(self, reporter):
		super().__init__()

		# Store the reporter
		self.reporter = reporter

	def run(self):
		"""
			This is the main entry point for workers...
		"""
		log.debug("Worker %s launched" % self.pid)

		# Reset signal handlers
		for signo in (signal.SIGINT, signal.SIGTERM):
			signal.signal(signo, signal.SIG_DFL)

		# Loop for forever
		while True:
			try:
				event = self.reporter.queue.get(block=True)

			# If the queue has been closed, we immediately exit
			except ValueError:
				break

			# Parse the event
			try:
				event = Event(event)

			# Skip any events we could not decode
			except ValueError as e:
				log.warning("Failed to decode event: %s" % e)
				continue

			# Log the event
			#log.debug("Received event in worker %s: %s" % (self.pid, event))

			# Process the event
			self.process(event)

		log.debug("Worker %s terminated" % self.pid)

	def process(self, event):
		"""
			Called whenever we have received an event
		"""
		# Process by type
		if event.type == "alert":
			return self.process_alert(event)

		# We don't care about anything else for now
		return

	def process_alert(self, event):
		"""
			Called to process alerts
		"""
		# Log the event
		log.debug("Received alert: %s" % event)

		# Send an email
		self.send_alert_email(event)

	def send_alert_email(self, event):
		"""
			Generates a new email with the alert
		"""
		# Create a new message
		msg = email.message.EmailMessage()

		msg.add_header("From", "IPFire Intrusion Prevention System <%s>" % EMAIL_FROM)
		msg.add_header("To", EMAIL_TO)
		msg.add_header("Subject", "[ALERT][%s] %s %s - %s" % (HOSTNAME,
			"*" * event.alert_severity, event.alert_signature, event.alert_category))

		# Add the timestamp as Date: header
		msg.add_header("Date", email.utils.format_datetime(event.timestamp))

		# Generate a Message ID
		msg.add_header("Message-ID", email.utils.make_msgid())

		# Compose the content
		content = [
			_("To whom it may concern,"),
			"",
			_("The IPFire Intrusion Preventsion System has raised the following alert:"),
			"",
			"	%-20s : %s" % (_("Signature"), event.alert_signature),
			"	%-20s : %s" % (_("Category"), event.alert_category),
			"	%-20s : %s" % (_("Severity"), event.alert_severity),
			"	%-20s : %s" % (_("Timestamp"), event.timestamp.strftime("%A, %d %B %Y at %H:%M:%S %Z")),
			"	%-20s : %s" % (_("Source"), event.source_address),
			"	%-20s : %s" % (_("Destination"), event.destination_address),
			"	%-20s : %s" % (_("Protocol"), event.protocol),
			"",
		]

		# Show if something was blocked
		if event.alert_action == "blocked":
			content += (
				_("The threat was blocked."), "",
			)

		# Add the content to the email
		msg.set_content("\n".join(content))

		# Log the generated email
		log.debug(msg.as_string())

		# Send the email
		p = subprocess.Popen(
			["/usr/sbin/sendmail", "-t", "-oi", "-f", EMAIL_FROM],
			text=True,
			stdin=subprocess.PIPE,
			stdout=subprocess.PIPE,
			stderr=subprocess.STDOUT,
		)

		# Pipe the email into sendmail
		stdout, stderr = p.communicate(msg.as_string())

		if not p.returncode == 0:
			log.error("Failed to send email. sendmail returned %s:" % p.returncode)
			if stdout:
				log.error(stdout)


class Event(object):
	def __init__(self, event):
		# Parse the event
		try:
			self.data = json.loads(event)

		# Raise some ValueError if we could not decode the input
		except json.JSONDecodeError as e:
			raise ValueError("%s" % e) from e

	def __str__(self):
		return "%s" % self.data

	@property
	def type(self):
		return self.data.get("event_type")

	@property
	def timestamp(self):
		t = self.data.get("timestamp")

		# Parse the timestamp
		return datetime.datetime.strptime(t, "%Y-%m-%dT%H:%M:%S.%f%z")

	@property
	def source_address(self):
		return self.data.get("src_ip")

	@property
	def destination_address(self):
		return self.data.get("dest_ip")

	@property
	def protocol(self):
		return self.data.get("proto")

	# Alert Stuff

	@property
	def alert(self):
		return self.data.get("alert")

	@property
	def alert_category(self):
		return self.alert.get("category")

	@property
	def alert_signature(self):
		return self.alert.get("signature")

	@property
	def alert_severity(self):
		return self.alert.get("severity", 0)

	@property
	def alert_action(self):
		return self.alert.get("action")



def setup_logging(loglevel=logging.INFO):
	log.setLevel(loglevel)

	# Log to syslog by default
	handler = logging.handlers.SysLogHandler(address="/dev/log", facility="daemon")
	log.addHandler(handler)

	# Format everything
	formatter = logging.Formatter("%(name)s[%(process)d]: %(message)s")
	handler.setFormatter(formatter)

	handler.setLevel(loglevel)

	# Write everything to the console, too
	handler = logging.StreamHandler()
	log.addHandler(handler)

	handler.setLevel(loglevel)

	return log

async def main():
	parser = argparse.ArgumentParser(description="Reporter Service for Suricata")

	# Command Line Arguments
	parser.add_argument("--verbose", "-v", action="count", help="Be more verbose")

	# Parse command line arguments
	args = parser.parse_args()

	# Setup logging
	loglevel = logging.WARN

	if args.verbose:
		if args.verbose == 1:
			loglevel = logging.INFO
		elif args.verbose >= 2:
			loglevel = logging.DEBUG

	setup_logging(loglevel=loglevel)

	# Create the repoert
	reporter = Reporter()

	# Run!
	await reporter.run()

if __name__ == "__main__":
	asyncio.run(main())
