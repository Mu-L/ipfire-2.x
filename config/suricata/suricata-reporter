#!/usr/bin/python3
###############################################################################
#                                                                             #
# IPFire.org - A linux based firewall                                         #
# Copyright (C) 2025  Michael Tremer                                          #
#                                                                             #
# This program is free software: you can redistribute it and/or modify        #
# it under the terms of the GNU General Public License as published by        #
# the Free Software Foundation, either version 3 of the License, or           #
# (at your option) any later version.                                         #
#                                                                             #
# This program is distributed in the hope that it will be useful,             #
# but WITHOUT ANY WARRANTY; without even the implied warranty of              #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the               #
# GNU General Public License for more details.                                #
#                                                                             #
# You should have received a copy of the GNU General Public License           #
# along with this program.  If not, see <http://www.gnu.org/licenses/>.       #
#                                                                             #
###############################################################################

import argparse
import asyncio
import logging
import logging.handlers
import multiprocessing
import signal
import sys

log = logging.getLogger("suricata-reporter")
log.setLevel(logging.DEBUG)

class Reporter(object):
	"""
		This is the main class that handles all the things...
	"""
	def __init__(self):
		# Fetch CPU count
		cpu_count = multiprocessing.cpu_count()

		# Fetch the current event loop
		self.loop = asyncio.get_running_loop()

		# Are we running?
		self.is_running = multiprocessing.Event()

		# Create an events queue
		self.queue = multiprocessing.Queue(1024)

		# Create as many workers as we have processors
		self.workers = [
			Worker(reporter=self) for _ in range(cpu_count)
		]

		# Register any signals
		for signo in (signal.SIGINT, signal.SIGTERM):
			self.loop.add_signal_handler(signo, self.terminate)

	async def run(self):
		"""
			The main loop of the application.
		"""
		log.debug("Starting reporter...")

		# We are now running
		self.is_running.set()

		# Start all workers
		for worker in self.workers:
			worker.start()

		# Sleep for forever
		while self.is_running.is_set():
			await asyncio.sleep(1)

			# Write some data into the queue
			self.queue.put("ABC", block=False)

		log.debug("Reporter has exited")

	def terminate(self):
		"""
			Called when the reporter is supposed to terminate.
		"""
		log.debug("Terminating...")

		# We are no longer running
		self.is_running.clear()

		# Terminate all workers
		for worker in self.workers:
			worker.terminate()

		# Wait until all workers have terminated
		for worker in self.workers:
			worker.join()


class Worker(multiprocessing.Process):
	def __init__(self, reporter):
		super().__init__()

		# Store the reporter
		self.reporter = reporter

	def run(self):
		"""
			This is the main entry point for workers...
		"""
		log.debug("Worker %s launched" % self.pid)

		# Reset signal handlers
		for signo in (signal.SIGINT, signal.SIGTERM):
			signal.signal(signo, signal.SIG_DFL)

		# Loop for forever
		while self.reporter.is_running.is_set():
			event = self.reporter.queue.get(block=True)

			# Log the event
			log.debug("Received event in worker %s: %s" % (self.pid, event))

		log.debug("Worker %s terminated" % self.pid)


def setup_logging(loglevel=logging.INFO):
	log.setLevel(loglevel)

	# Log to syslog by default
	handler = logging.handlers.SysLogHandler(address="/dev/log", facility="daemon")
	log.addHandler(handler)

	# Format everything
	formatter = logging.Formatter("%(name)s[%(process)d]: %(message)s")
	handler.setFormatter(formatter)

	handler.setLevel(loglevel)

	# Write everything to the console, too
	handler = logging.StreamHandler()
	log.addHandler(handler)

	handler.setLevel(loglevel)

	return log

async def main():
	parser = argparse.ArgumentParser(description="Reporter Service for Suricata")

	# Command Line Arguments
	parser.add_argument("--verbose", "-v", action="count", help="Be more verbose")

	# Parse command line arguments
	args = parser.parse_args()

	# Setup logging
	loglevel = logging.WARN

	if args.verbose:
		if args.verbose == 1:
			loglevel = logging.INFO
		elif args.verbose >= 2:
			loglevel = logging.DEBUG

	setup_logging(loglevel=loglevel)

	# Create the repoert
	reporter = Reporter()

	# Run!
	await reporter.run()

if __name__ == "__main__":
	asyncio.run(main())
